<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Robot Builder V27 - Precision Tracing</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #0e0e10; color: #eee; display: flex; }
        canvas { width: 100vw; height: 100vh; touch-action: none; outline: none; }
        #controls {
            position: absolute; left: 10px; top: 10px; width: 460px;
            background: rgba(20, 20, 25, 0.98); padding: 15px; border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.9); z-index: 10; border: 1px solid #444;
            max-height: 95vh; overflow-y: auto;
        }
        .panel { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #444; }
        h3 { margin: 0 0 10px 0; font-size: 14px; color: #ff9f43; text-transform: uppercase; }
        h4 { margin: 15px 0 8px 0; font-size: 12px; color: #5dade2; border-top: 1px solid #333; padding-top: 10px; display:flex; justify-content:space-between; align-items: center; }
        .control-row { display: flex; align-items: center; gap: 4px; margin-bottom: 6px; }
        .control-row label { flex: 0.8; font-size: 10px; color: #bbb; text-transform: uppercase; }
        .control-row input[type=range] { flex: 1.1; }
        .val-display { font-family: monospace; font-size: 10px; color: #ff9f43; background: #000; padding: 2px 4px; border-radius: 3px; min-width: 45px; text-align: center; }
        input[type=text], input[type=color], select { background: #1a1a1a; border: 1px solid #444; color: white; padding: 5px; border-radius: 4px; font-size: 11px; }
        .btn-tool { background: #3a3a3a; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 3px 5px; cursor: pointer; font-size: 9px; font-weight: bold; min-width: 32px; }
        button { width: 100%; padding: 10px; margin: 4px 0; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; background: #4a4a4a; color: white; transition: 0.2s; }
        .btn-add { background: #27ae60 !important; }
        .btn-new { background: #c0392b !important; margin-bottom: 10px; }
        .btn-restore { background: #d35400 !important; margin-bottom: 10px; }
        .btn-play { background: #2980b9 !important; }
        .btn-trace { background: #2c3e50 !important; border: 1px solid #34495e !important; }
        .btn-trace.active { background: #f1c40f !important; color: #000 !important; }
        .mapping-box { background: #151518; padding: 10px; border-radius: 8px; margin-top: 10px; border: 1px solid #555; }
        .mapping-row { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #333; }
        .mapping-label { font-size: 11px; color: #0f0; font-family: monospace; margin-bottom: 8px; display: block; }
    </style>
</head>
<body>

<div id="controls">
    <div class="panel">
        <h3>Progetto Robot</h3>
        <button class="btn-new" onclick="resetProject()">NUOVO PROGETTO</button>
        <button class="btn-restore" id="btnRestore" style="display:none;" onclick="restoreToInitialState()">RIPRISTINA POSIZIONE ORIGINALE</button>
        <button class="btn-add" onclick="addNewArm()">+ AGGIUNGI & AGGANCIA</button>
        <div style="display:flex; gap:5px;">
            <button onclick="saveProject()">SALVA JSON</button>
            <button onclick="document.getElementById('fileLoad').click()">CARICA</button>
        </div>
        <input type="file" id="fileLoad" style="display:none" onchange="loadProject(event)">
    </div>

    <div class="panel">
        <h3>Animazione & Tracciamento</h3>
        <button style="background:#8e44ad" onclick="document.getElementById('animLoad').click()">CARICA FILE TRAIETTORIA (.json)</button>
        <input type="file" id="animLoad" style="display:none" onchange="loadAnimationData(event)">
        
        <div style="display:flex; gap:5px; margin-top:5px;">
            <button class="btn-trace" id="btnTrace" onclick="toggleTracing()">ATTIVA TRACCE</button>
            <button class="btn-trace" onclick="clearTraces()">CANCELLA TRACCE</button>
        </div>

        <div id="animMappingArea" style="display:none;" class="mapping-box">
            <div id="mappingList"></div>
        </div>

        <div id="playbackControls" style="display:none; margin-top:10px;">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                <button class="btn-play" id="btnPlay" onclick="togglePlay()">PLAY</button>
                <button onclick="stopAnim()">STOP</button>
                <button onclick="rewindAnim()">RIAVVOLGI</button>
                <button onclick="stepAnim(1)">FRAME +1</button>
            </div>
            <div id="v_frameCounter" style="text-align:center; font-size:11px; margin-top:8px; color:#ff9f43; font-family: monospace;">Frame: 0 / 0</div>
        </div>
    </div>

    <div id="selectionPanel" style="display:none;">
        <h3 id="selectedTitle">-</h3>
        <div id="armControls">
            <h4>Anagrafica Braccio</h4>
            <div class="control-row"><input type="text" id="armName" style="flex:2" oninput="updateFromUI()"><input type="color" id="armColor" style="margin-left:10px;" oninput="updateFromUI()"></div>
            <h4>Traslazione (W=0.3)</h4>
            <div class="control-row"><label>X</label><button class="btn-tool" onclick="stepField('worldX', -0.3)">-</button><input type="range" id="worldX" min="-10" max="10" step="0.01" oninput="updateFromUI()"><button class="btn-tool" onclick="stepField('worldX', 0.3)">+</button><span class="val-display" id="v_worldX">0.0</span><button class="btn-tool btn-reset" style="color:#ff5e57" onclick="resetField('worldX', 0)">R</button></div>
            <div class="control-row"><label>Y</label><button class="btn-tool" onclick="stepField('worldY', -0.3)">-</button><input type="range" id="worldY" min="-10" max="10" step="0.01" oninput="updateFromUI()"><button class="btn-tool" onclick="stepField('worldY', 0.3)">+</button><span class="val-display" id="v_worldY">0.0</span><button class="btn-tool btn-reset" style="color:#ff5e57" onclick="resetField('worldY', 0)">R</button></div>
            <div class="control-row"><label>Z</label><button class="btn-tool" onclick="stepField('worldZ', -0.3)">-</button><input type="range" id="worldZ" min="-10" max="10" step="0.01" oninput="updateFromUI()"><button class="btn-tool" onclick="stepField('worldZ', 0.3)">+</button><span class="val-display" id="v_worldZ">0.0</span><button class="btn-tool btn-reset" style="color:#ff5e57" onclick="resetField('worldZ', 0)">R</button></div>
            <h4>Geometria</h4>
            <div class="control-row"><label>Lunghezza</label><input type="range" id="segLength" min="0.1" max="10" step="0.1" value="2.0" oninput="updateFromUI()"><span class="val-display" id="v_segLength">2.0</span></div>
            <div class="control-row"><label>Dist. A</label><input type="range" id="pA_dist" min="-5" max="5" step="0.01" oninput="updateFromUI()"><span class="val-display" id="v_pA_dist">0.0</span></div>
            <div class="control-row"><label>Dist. B</label><input type="range" id="pB_dist" min="-5" max="5" step="0.01" oninput="updateFromUI()"><span class="val-display" id="v_pB_dist">0.0</span></div>
            <h4>Rotazione</h4>
            <div class="control-row"><label>Rot X</label><button class="btn-tool" onclick="setRot('rotX', -90)">-90</button><button class="btn-tool" onclick="setRot('rotX', 0)">0</button><input type="range" id="rotX" min="-180" max="180" step="1" oninput="updateFromUI()"><button class="btn-tool" onclick="setRot('rotX', 90)">+90</button><span class="val-display" id="v_rotX">0°</span></div>
            <div class="control-row"><label>Rot Y</label><button class="btn-tool" onclick="setRot('rotY', -90)">-90</button><button class="btn-tool" onclick="setRot('rotY', 0)">0</button><input type="range" id="rotY" min="-180" max="180" step="1" oninput="updateFromUI()"><button class="btn-tool" onclick="setRot('rotY', 90)">+90</button><span class="val-display" id="v_rotY">0°</span></div>
            <div class="control-row"><label>Rot Z</label><button class="btn-tool" onclick="setRot('rotZ', -90)">-90</button><button class="btn-tool" onclick="setRot('rotZ', 0)">0</button><input type="range" id="rotZ" min="-180" max="180" step="1" oninput="updateFromUI()"><button class="btn-tool" onclick="setRot('rotZ', 90)">+90</button><span class="val-display" id="v_rotZ">0°</span></div>
            <h4>Aggancio</h4>
            <select id="pivotSelect" onchange="attachArm()"></select>
        </div>
        <div id="rootControls" style="display:none;">
            <h4>Base</h4>
            <div class="control-row"><label>Gira</label><input type="range" id="rootRotY" min="-180" max="180" step="1" oninput="updateRoot()"><span class="val-display" id="v_rootRotY">0°</span></div>
        </div>
        <button class="danger" onclick="deleteArm()">ELIMINA SELEZIONATO</button>
    </div>
</div>
<canvas id="renderCanvas"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
let scene, camera, arms = [], armCounter = 0, selectedArm = null;

// --- STATE ---
let initialProjectSnapshot = null; 
let animData = null;
let currentFrame = 0;
let isPlaying = false;
let mappingConfig = {}; 
let isTracingActive = false;
let rootNode = null;

// --- TRACING STORAGE ---
let tracingPoints = new Map(); // generatorNodeName -> Vector3[]
let tracingLines = new Map();  // generatorNodeName -> LinesMesh

const createScene = () => {
    scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.08, 1);
    camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3, 15, new BABYLON.Vector3(0, 2, 0), scene);
    camera.attachControl(canvas, true);
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0.5, 1, 0), scene).intensity = 0.8;
    new BABYLON.PointLight("pLight", new BABYLON.Vector3(-10, 10, -10), scene).intensity = 0.5;
    scene.setRenderingAutoClearDepthStencil(1, false, false, false);

    rootNode = new BABYLON.TransformNode("ROOT_PIVOT", scene);
    createVisuals(rootNode, BABYLON.Color3.Red(), "ROOT");

    scene.onPointerDown = (evt, pickResult) => {
        if (pickResult.hit) {
            const mesh = pickResult.pickedMesh;
            const arm = (mesh.metadata && mesh.metadata.armRef) ? mesh.metadata.armRef : null;
            if (arm) selectArm(arm);
            else if (mesh.name.includes("ROOT_PIVOT") || (mesh.metadata && mesh.metadata.type === "ROOT")) selectArm("ROOT");
        }
    };

    scene.onBeforeRenderObservable.add(() => {
        // 1. Esegui Animazione se Play attivo
        if (isPlaying && animData && animData.frames) {
            applyFrame(currentFrame);
            currentFrame++;
            if (currentFrame >= animData.frames.length) currentFrame = 0;
            updateAnimUI();
        }

        // 2. Registra Tracce se attivo
        if (isTracingActive) {
            updateAllTraces();
        }
    });

    return scene;
};

// --- NEW TRACING ENGINE (ROBUST) ---
function toggleTracing() {
    isTracingActive = !isTracingActive;
    const btn = document.getElementById("btnTrace");
    btn.innerText = isTracingActive ? "DISATTIVA TRACCE" : "ATTIVA TRACCE";
    btn.classList.toggle("active", isTracingActive);
    if (!isTracingActive) {
        // Nascondi ma non cancellare per ora? No, cancelliamo per chiarezza
        clearTraces();
    }
}

function clearTraces() {
    tracingLines.forEach(line => line.dispose());
    tracingLines.clear();
    tracingPoints.clear();
}

function updateAllTraces() {
    // Traccia per ROOT
    recordPoint(rootNode, BABYLON.Color3.Red());
    // Traccia per ogni pivot di ogni braccio
    arms.forEach(a => {
        const n = a.customData.nodes;
        recordPoint(n.inletPoint, BABYLON.Color3.Blue());
        recordPoint(n.outletPoint, BABYLON.Color3.Green());
    });
}

function recordPoint(node, color) {
    const name = node.name;
    const pos = node.getAbsolutePosition().clone();
    
    if (!tracingPoints.has(name)) {
        tracingPoints.set(name, []);
    }
    
    const points = tracingPoints.get(name);
    
    // Evita di registrare punti identici (ottimizzazione)
    if (points.length > 0) {
        const last = points[points.length - 1];
        if (BABYLON.Vector3.Distance(last, pos) < 0.01) return;
    }
    
    points.push(pos);
    
    // Limita a 5000 punti per scia per non esplodere la memoria
    if (points.length > 5000) points.shift();

    // Aggiorna o crea la linea
    if (points.length > 1) {
        if (tracingLines.has(name)) {
            tracingLines.get(name).dispose();
        }
        const line = BABYLON.MeshBuilder.CreateLines("l_" + name, { points: points, updatable: false }, scene);
        line.color = color;
        line.renderingGroupId = 1;
        tracingLines.set(name, line);
    }
}

// --- ANIMATION ENGINE ---
function loadAnimationData(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            animData = JSON.parse(e.target.result);
            document.getElementById("animMappingArea").style.display = "block";
            document.getElementById("playbackControls").style.display = "block";
            buildMappingUI();
            currentFrame = 0;
            updateAnimUI();
        } catch(err) { alert("File Animazione non valido"); }
    };
    reader.readAsText(file);
}

function buildMappingUI() {
    const container = document.getElementById("mappingList");
    container.innerHTML = "";
    if (!animData || !animData.frames[0]) return;
    const keys = Object.keys(animData.frames[0].angles);
    keys.forEach(key => {
        mappingConfig[key] = mappingConfig[key] || { armId: "", axis: "rotX", offset: 0, sign: 1 };
        const row = document.createElement("div");
        row.className = "mapping-row";
        row.innerHTML = `
            <span class="mapping-label">Dato JSON: <strong>${key}</strong></span>
            <div class="control-row">
                <select onchange="mappingConfig['${key}'].armId = this.value">
                    <option value="">-- Braccio --</option>
                    ${arms.map(a => `<option value="${a.id}" ${mappingConfig[key].armId === a.id ? 'selected' : ''}>${a.customData.name}</option>`).join('')}
                </select>
                <select onchange="mappingConfig['${key}'].axis = this.value" style="width:70px;">
                    <option value="rotX" ${mappingConfig[key].axis==='rotX'?'selected':''}>Asse X</option>
                    <option value="rotY" ${mappingConfig[key].axis==='rotY'?'selected':''}>Asse Y</option>
                    <option value="rotZ" ${mappingConfig[key].axis==='rotZ'?'selected':''}>Asse Z</option>
                </select>
                <select onchange="mappingConfig['${key}'].sign = parseInt(this.value)" style="width:50px;">
                    <option value="1" ${mappingConfig[key].sign===1?'selected':''}>+</option>
                    <option value="-1" ${mappingConfig[key].sign===-1?'selected':''}>-</option>
                </select>
            </div>
            <div class="control-row">
                <button class="btn-tool" onclick="setAnimOffset('${key}', -180)">-180</button>
                <button class="btn-tool" onclick="setAnimOffset('${key}', -90)">-90</button>
                <button class="btn-tool" onclick="setAnimOffset('${key}', 0)">0</button>
                <button class="btn-tool" onclick="setAnimOffset('${key}', 90)">+90</button>
                <span id="v_off_${key}" style="font-size:10px; margin-left:5px; color:#ff9f43">${mappingConfig[key].offset}°</span>
            </div>
        `;
        container.appendChild(row);
    });
}

function setAnimOffset(key, val) {
    mappingConfig[key].offset = val;
    const disp = document.getElementById(`v_off_${key}`);
    if(disp) disp.innerText = val + "°";
}

function applyFrame(idx) {
    const frame = animData.frames[idx];
    if (!frame) return;
    Object.keys(frame.angles).forEach(key => {
        const config = mappingConfig[key];
        if (config && config.armId) {
            const arm = arms.find(a => a.id === config.armId);
            if (arm) {
                const rawDeg = BABYLON.Tools.ToDegrees(frame.angles[key]);
                arm.customData[config.axis] = (rawDeg * config.sign) + config.offset;
                applyArmData(arm);
            }
        }
    });
    if (selectedArm && selectedArm.customData) syncArmUI();
}

function togglePlay() { isPlaying = !isPlaying; document.getElementById("btnPlay").innerText = isPlaying ? "PAUSA" : "PLAY"; }
function stopAnim() { isPlaying = false; currentFrame = 0; applyFrame(0); updateAnimUI(); document.getElementById("btnPlay").innerText = "PLAY"; }
function rewindAnim() { currentFrame = 0; applyFrame(0); updateAnimUI(); }
function stepAnim(n) { currentFrame = (currentFrame + n) % animData.frames.length; applyFrame(currentFrame); updateAnimUI(); }
function updateAnimUI() { if(animData) document.getElementById("v_frameCounter").innerText = `Frame: ${currentFrame} / ${animData.frames.length}`; }

// --- SNAPSHOT / RESTORE ---
function takeSnapshot() {
    initialProjectSnapshot = arms.map(a => ({
        id: a.id,
        parentId: a.customData.nodes.pA.parent ? a.customData.nodes.pA.parent.name : null,
        absPos: a.customData.nodes.pA.position.asArray(),
        d: { ...a.customData, nodes: null }
    }));
    document.getElementById("btnRestore").style.display = "block";
}

function restoreToInitialState() {
    if (!initialProjectSnapshot) return;
    initialProjectSnapshot.forEach(state => {
        const arm = arms.find(a => a.id === state.id);
        if (arm) {
            const nodesBackup = arm.customData.nodes;
            Object.assign(arm.customData, JSON.parse(JSON.stringify(state.d)));
            arm.customData.nodes = nodesBackup;
            const pA = arm.customData.nodes.pA;
            if (state.parentId) {
                const parent = scene.getTransformNodeByName(state.parentId);
                if (parent) { pA.parent = parent; pA.position.set(0, 0, 0); }
            } else {
                pA.parent = null;
                pA.position.fromArray(state.absPos);
            }
            applyArmData(arm);
        }
    });
    if (selectedArm && selectedArm.customData) syncArmUI();
    refreshPivotList();
    clearTraces();
}

// --- CORE SYSTEM ---
function createVisuals(node, color, type, armRef = null) {
    const sphere = BABYLON.MeshBuilder.CreateSphere("viz_" + node.name, {diameter: 0.25}, scene);
    sphere.parent = node;
    sphere.renderingGroupId = 1;
    const mat = new BABYLON.StandardMaterial("vMat", scene);
    mat.diffuseColor = color; mat.emissiveColor = color.scale(0.3);
    sphere.material = mat;
    sphere.metadata = { type: type, armRef: armRef };
    const axes = [{d:new BABYLON.Vector3(1,0,0),c:BABYLON.Color3.Red()},{d:new BABYLON.Vector3(0,1,0),c:BABYLON.Color3.Green()},{d:new BABYLON.Vector3(0,0,1),c:BABYLON.Color3.Blue()}];
    axes.forEach(a => {
        const line = BABYLON.MeshBuilder.CreateCylinder("ax", {height: 1.2, diameter: 0.03}, scene);
        line.parent = node; line.renderingGroupId = 1;
        const lMat = new BABYLON.StandardMaterial("aMat", scene);
        lMat.emissiveColor = a.c; line.material = lMat;
        line.metadata = { type: type, armRef: armRef };
        if(a.d.x) line.rotation.z = Math.PI/2;
        if(a.d.z) line.rotation.x = Math.PI/2;
    });
}

function addNewArm(forcedId = null) {
    const id = forcedId || "Braccio_" + (armCounter++);
    const pA = new BABYLON.TransformNode("PivotA_" + id, scene);
    const offsetNode = new BABYLON.TransformNode("Offset_" + id, scene);
    const rotator = new BABYLON.TransformNode("Rotator_" + id, scene);
    const inletPoint = new BABYLON.TransformNode("Inlet_" + id, scene);
    const outletPoint = new BABYLON.TransformNode("Outlet_" + id, scene);
    offsetNode.parent = pA; rotator.parent = offsetNode; inletPoint.parent = rotator; outletPoint.parent = rotator;
    const mesh = BABYLON.MeshBuilder.CreateBox(id, {width: 0.6, height: 1, depth: 0.6}, scene);
    mesh.parent = rotator;
    mesh.material = new BABYLON.StandardMaterial("mat_" + id, scene);
    mesh.metadata = { type: "arm", armRef: mesh };
    mesh.customData = { 
        name: id, color: "#666666", segLength: 2.0, worldX: 0, worldY: 0, worldZ: 0, 
        rotX: 0, rotY: 0, rotZ: 0, pA_dist: 0, pB_dist: 0,
        nodes: { pA, offsetNode, rotator, inletPoint, outletPoint }
    };
    createVisuals(inletPoint, BABYLON.Color3.Blue(), "A", mesh);
    createVisuals(outletPoint, BABYLON.Color3.Green(), "B", mesh);
    if (!forcedId && arms.length > 0) {
        pA.parent = arms[arms.length-1].customData.nodes.outletPoint;
        pA.position.set(0,0,0);
    } else if (!forcedId) pA.position.y = 1;
    arms.push(mesh);
    applyArmData(mesh);
    if(animData) buildMappingUI();
    selectArm(mesh);
    return mesh;
}

function selectArm(arm) {
    resetColors();
    document.getElementById("selectionPanel").style.display = "block";
    if (arm === "ROOT") {
        selectedArm = rootNode;
        document.getElementById("armControls").style.display = "none";
        document.getElementById("rootControls").style.display = "block";
        syncRootUI();
    } else {
        selectedArm = arm;
        selectedArm.material.diffuseColor = BABYLON.Color3.Yellow();
        document.getElementById("armControls").style.display = "block";
        document.getElementById("rootControls").style.display = "none";
        syncArmUI();
        refreshPivotList();
    }
}

function syncArmUI() {
    if (!selectedArm || !selectedArm.customData) return;
    const d = selectedArm.customData;
    document.getElementById("selectedTitle").innerText = d.name;
    document.getElementById("armName").value = d.name;
    document.getElementById("armColor").value = d.color;
    ['worldX','worldY','worldZ','segLength','pA_dist','pB_dist','rotX','rotY','rotZ'].forEach(f => {
        const el = document.getElementById(f);
        const disp = document.getElementById('v_'+f);
        if (el) el.value = d[f];
        if (disp) disp.innerText = f.includes('rot') ? Math.round(d[f])+"°" : d[f].toFixed(1);
    });
}

function updateFromUI() {
    if (!selectedArm || !selectedArm.customData) return;
    const d = selectedArm.customData;
    d.name = document.getElementById("armName").value;
    d.color = document.getElementById("armColor").value;
    ['worldX','worldY','worldZ','segLength','pA_dist','pB_dist','rotX','rotY','rotZ'].forEach(f => {
        const el = document.getElementById(f);
        if (el) d[f] = parseFloat(el.value);
    });
    applyArmData(selectedArm);
    syncArmUI();
}

function applyArmData(arm) {
    if (!arm || !arm.customData) return;
    const d = arm.customData;
    const n = d.nodes;
    n.offsetNode.position.set(d.worldX, d.worldY, d.worldZ);
    n.rotator.rotation.set(BABYLON.Tools.ToRadians(d.rotX), BABYLON.Tools.ToRadians(d.rotY), BABYLON.Tools.ToRadians(d.rotZ));
    arm.scaling.y = d.segLength;
    arm.position.y = (d.segLength / 2) + d.pA_dist;
    n.inletPoint.position.y = d.pA_dist;
    n.outletPoint.position.y = d.segLength + d.pA_dist + d.pB_dist;
    arm.material.diffuseColor = (selectedArm === arm) ? BABYLON.Color3.Yellow() : BABYLON.Color3.FromHexString(d.color);
}

function resetColors() { arms.forEach(a => { if(a.customData) a.material.diffuseColor = BABYLON.Color3.FromHexString(a.customData.color); }); }
function stepField(id, delta) { document.getElementById(id).value = (parseFloat(document.getElementById(id).value) + delta).toFixed(2); updateFromUI(); }
function setRot(id, val) { document.getElementById(id).value = val; updateFromUI(); }
function resetField(id, val) { document.getElementById(id).value = val; updateFromUI(); }

function syncRootUI() {
    const deg = Math.round(BABYLON.Tools.ToDegrees(selectedArm.rotation.y));
    document.getElementById("rootRotY").value = deg;
    document.getElementById("v_rootRotY").innerText = deg + "°";
    document.getElementById("selectedTitle").innerText = "Base Robot";
}

function updateRoot() {
    const deg = parseFloat(document.getElementById("rootRotY").value);
    selectedArm.rotation.y = BABYLON.Tools.ToRadians(deg);
    document.getElementById("v_rootRotY").innerText = deg + "°";
}

function refreshPivotList() {
    const select = document.getElementById("pivotSelect");
    if(!select || !selectedArm.customData) return;
    const current = selectedArm.customData.nodes.pA.parent ? selectedArm.customData.nodes.pA.parent.name : "";
    select.innerHTML = '<option value="">-- Libero --</option><option value="ROOT_PIVOT">Base (ROOT)</option>';
    arms.forEach(a => {
        if (a === selectedArm) return;
        select.innerHTML += `<option value="${a.customData.nodes.inletPoint.name}">${a.customData.name} (Inlet)</option>`;
        select.innerHTML += `<option value="${a.customData.nodes.outletPoint.name}">${a.customData.name} (Outlet)</option>`;
    });
    select.value = current;
}

function attachArm() {
    const targetName = document.getElementById("pivotSelect").value;
    const pA = selectedArm.customData.nodes.pA;
    if (targetName === "") pA.parent = null;
    else { const t = scene.getTransformNodeByName(targetName); if (t) { pA.parent = t; pA.position.set(0,0,0); } }
    clearTraces();
}

function deleteArm() {
    if (!selectedArm || selectedArm.name === "ROOT_PIVOT") return;
    selectedArm.customData.nodes.pA.dispose();
    arms = arms.filter(a => a !== selectedArm);
    document.getElementById("selectionPanel").style.display = "none";
    if(animData) buildMappingUI();
    clearTraces();
}

function resetProject() {
    if(confirm("Vuoi cancellare tutto?")) {
        arms.forEach(a => a.customData.nodes.pA.dispose());
        arms = []; armCounter = 0; isPlaying = false; animData = null; initialProjectSnapshot = null;
        document.getElementById("selectionPanel").style.display = "none";
        document.getElementById("playbackControls").style.display = "none";
        document.getElementById("animMappingArea").style.display = "none";
        document.getElementById("btnRestore").style.display = "none";
        clearTraces();
    }
}

function saveProject() {
    const data = arms.map(a => ({ id: a.id, parentId: a.customData.nodes.pA.parent ? a.customData.nodes.pA.parent.name : null, absPos: a.customData.nodes.pA.position.asArray(), d: { ...a.customData, nodes: null } }));
    const blob = new Blob([JSON.stringify(data, null, 4)], {type: "application/json"});
    const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "robot.json"; a.click();
}

function loadProject(event) {
    const reader = new FileReader();
    reader.onload = (e) => {
        const data = JSON.parse(e.target.result);
        arms.forEach(a => a.customData.nodes.pA.dispose()); arms = [];
        data.forEach(item => {
            const a = addNewArm(item.id); Object.assign(a.customData, item.d);
            a.customData.nodes = { pA: scene.getTransformNodeByName("PivotA_" + a.id), offsetNode: scene.getTransformNodeByName("Offset_" + a.id), rotator: scene.getTransformNodeByName("Rotator_" + a.id), inletPoint: scene.getTransformNodeByName("Inlet_" + a.id), outletPoint: scene.getTransformNodeByName("Outlet_" + a.id) };
            if (item.absPos) a.customData.nodes.pA.position.fromArray(item.absPos);
            applyArmData(a);
        });
        data.forEach(item => {
            if (item.parentId) {
                const child = scene.getTransformNodeByName("PivotA_" + item.id);
                const parent = scene.getTransformNodeByName(item.parentId);
                if (child && parent) { child.parent = parent; child.position.set(0,0,0); }
            }
        });
        armCounter = data.length > 0 ? Math.max(...data.map(d => parseInt(d.id.split('_')[1] || 0))) + 1 : 0;
        document.getElementById("selectionPanel").style.display = "none";
        takeSnapshot();
        refreshPivotList();
        clearTraces();
    };
    reader.readAsText(event.target.files[0]);
}

scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>